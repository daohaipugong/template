---
title: 计算几何
mathjax: true
categories: # 分类
  - c++板子  # 只能由一个
tags: # 标签
  - 计算几何  # 能有多个
  - 算法  # 一个标签一行
  - c++
---

# 计算几何

[计算几何基本模板（二维）](https://www.cnblogs.com/oneway10101/p/17642080.html#求多边形面积polygon_area)

https://www.cnblogs.com/genshy/p/14350738.html

<!-- more -->

```cpp
const double eps = 1e-8;
const double pi = acos(-1.0);

template<typename T>
struct Point {
    T x, y;
    bool operator==(const Point& b)const { return (abs(x - b.x) <= eps && abs(y - b.y) <= eps); }
    bool operator<(const Point& b)const {
        return (abs(x - b.x) <= eps) ? (y < b.y - eps) : (x < b.x - eps);
    }
    Point operator+(const Point& b)const { return { x + b.x,y + b.y }; }
    Point operator-(const Point& b)const { return { x - b.x,y - b.y }; }
    Point operator-()const { return { -x,-y }; }
    Point operator*(const T k)const { return { x * k,y * k }; }
    Point operator/(const T k)const { return { x / k,y / k }; }
    T operator*(const Point& b)const { return x * b.x + y * b.y; }  // 点乘
    T operator^(const Point& b)const { return x * b.y - y * b.x; }  // 叉乘
    bool is_ver(const Point& b)const { return abs(*this * b) <= eps; }  // 垂直
    bool is_par(const Point& b)const { return abs(*this ^ b) <= eps; }  // 平行
    int toleft(const Point& b)const { T c = *this ^ b; return (c > eps) - (c < -eps); }

};
```

**直线方向向量**

对 $Ax+By+C=0$ , 法向量 $(A, B)$ , 方向向量 $(-B, A)$ 。

设一般方程: $A x+B y+C=0$
写成斜截式： $y=-\frac{A}{B} x-\frac{C}{B}$
那么它的斜率 $k=-\frac{A}{B}$
过原点做一条平行线 $y=-\frac{A}{B} x$
取 $x=B$ ，得到 $y=-A$.那么得到一个方向向量即 $\alpha=(B,-A)$ 。

**两直线交点**

直线 $l_1$ 的一般式为：$$ A_1x + B_1y + C_1 = 0 $$
直线 $l_2$ 的一般式为：$$ A_2x + B_2y + C_2 = 0 $$

两条直线 $l_1$ 和 $l_2$ 的交点是：
$$
\left( \frac{B_1C_2 - B_2C_1}{A_1B_2 - A_2B_1}, \frac{A_1C_2 - A_2C_1}{A_2B_1 - A_1B_2} \right)
$$

注意：如果 $A_2B_1 - A_1B_2 = 0$，则方程组无解（平行且不重合）或有无穷多解（重合）。

**直线一般式**

$fs(x)$ 防止输出 $-0.00$ 。

```cpp
const double eps = 1e-6;
#define fs(x) (abs(x) < eps) ? 0 : (x)
struct node {
	long long x, y;

	bool operator==(const node& b)const {
		return x == b.x && y == b.y;
	}
};

struct Point {
	double x, y;
};

struct Line {
	long long a, b, c;

	bool operator<(const Line& l)const {
		return a == l.a ? (b == l.b ? c < l.c : b < l.b) : (a < l.a);
	}

	bool operator==(const Line& l)const {
		return a == l.a && b == l.b && c == l.c;
	}

	// 直线是否过点A
	bool through(node A) {
		return a * A.x + b * A.y + c == 0;
	}
};

// l1,l2是否相交
bool intersect(Line l1, Line l2) {
	return !(l1.a * l2.b == l1.b * l2.a);
}

// l1,l2交点
Point intersection(Line l1, Line l2) {
	double A1 = l1.a, B1 = l1.b, C1 = l1.c, A2 = l2.a, B2 = l2.b, C2 = l2.c;
	return { (B1 * C2 - B2 * C1) / (A1 * B2 - A2 * B1),(A1 * C2 - A2 * C1) / (A2 * B1 - A1 * B2) };
}

long long gcd(long long a, long long b) {
	if (!b) return a;
	return gcd(b, a % b);
}

// x1,x2不能相等
Line make_line(node x1, node x2) {
	long long a = x1.y - x2.y;
	long long b = x2.x - x1.x;
	long long c = x1.x * x2.y - x1.y * x2.x;
	long long g = gcd(a, gcd(b, c));
	a /= g, b /= g, c /= g;
	if (a < 0) {
		a = -a, b = -b, c = -c;
	}
	return Line{ a,b,c };
}
```

**凸包**

```cpp
const double Pi = 3.141592653589793;
struct Point {
	double x, y;

	bool operator<(const Point& b)const {
		return x != b.x ? x < b.x : y < b.y;
	}

	Point operator+(const Point& b)const {
		return { x + b.x,y + b.y };
	}

    // 向量
	Point operator-(const Point& b)const {
		return { x - b.x,y - b.y };
	}

    // 点积
	double operator*(const Point& b)const {
		return x * b.x + y * b.y;
	}

    // 叉积
	double operator^(const Point& b)const {
		return x * b.y - y * b.x;
	}

    // 两点距离
	double dis(Point b) {
		return hypot(x - b.x, y - b.y);
	}

    // 绕p逆时针转angle弧度
	Point rotate(Point p, double angle) {
		Point v = (*this) - p;
		double c = cos(angle), s = sin(angle);
		return { p.x + v.x * c - v.y * s,p.y + v.y * c + v.x * s };
	}
};

//线段AB和线段CD的交点 
//用的时候记得要特判一下两直线是否平行
Point jiao_LL(Point A, Point B, Point C, Point D) {
    Point v = B - A, w = D - C, PQ = A - C;

    double t = (PQ ^ w) / (w ^ v);
    return A + Point{ v.x * t,v.y * t };
}

bool is_right(Point a, Point b, Point c) {
	return ((c - a) ^ (b - a)) >= 0;
}

sort(p + 1, p + 1 + size);
for (int i = 1; i <= size; i++) {
	while (tt >= 2 && is_right(stk[tt - 1], stk[tt], p[i])) tt--;
	stk[++tt] = p[i];
}
int len = tt;
for (int i = size; i >= 1; i--) {
	while (tt >= len + 1 && is_right(stk[tt - 1], stk[tt], p[i])) tt--;
	stk[++tt] = p[i];
}
```

